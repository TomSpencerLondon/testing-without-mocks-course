// Copyright Titanium I.T. LLC.
import * as ensure from "util/ensure.js";
import http from "node:http";
import EventEmitter from "node:events";
import { OutputListener } from "util/output_listener.js";
import { ConfigurableResponses } from "util/configurable_responses.js";

/** A general-purpose HTTP client. */
export class HttpClient {

	/**
	 * Factory method. Creates the client.
	 * @returns {HttpClient} the client
	 */
	static create() {
		ensure.signature(arguments, []);

		return new HttpClient();
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor() {
	}

	/**
	 * Make the HTTP request. Does not have the ability to cancel the request.
	 * The response is an object containing { status, headers, body }.
	 * @param host the host to call
	 * @param port the port to use
	 * @param method the request method
	 * @param path the request path (URL)
	 * @param [headers] the request headers
	 * @param [body] the request body
	 * @returns {Promise} the response promise
	 */
	async requestAsync({ host, port, method, path, headers, body }) {
		const clientRequest = this.#sendRequest(host, port, method, path, headers, body);
		return await this.#handleResponseAsync(clientRequest);
	}

	#sendRequest(host, port, method, path, headers, body) {
		const clientRequest = http.request({
			host: host,
			port: port,
			method: method,
			path: path,
			headers: headers,
		});
		clientRequest.end(body);

		return clientRequest;
	}

	async #handleResponseAsync(clientRequest) {
		return await new Promise((resolve, reject) => {
			clientRequest.on("response", (clientResponse) => {
				let body = "";
				clientResponse.on("data", (chunk) => {
					body += chunk;
				});

				clientResponse.on("end", () => {
					resolve({
						status: clientResponse.statusCode,
						headers: clientResponse.headers,
						body,
					});
				});
			});
		});
	}

}
