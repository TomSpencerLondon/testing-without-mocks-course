// Copyright Titanium I.T. LLC.
import * as ensure from "util/ensure.js";
import http from "node:http";
import EventEmitter from "node:events";
import { OutputListener } from "util/output_listener.js";
import { ConfigurableResponses } from "util/configurable_responses.js";

const DEFAULT_NULLED_RESPONSE = {
	status: 503,
	headers: { nulledhttpclient: "default header" },
	body: "Nulled HttpClient default body",
};

/** A general-purpose HTTP client. */
export class HttpClient {

	/**
	 * Factory method. Creates the client.
	 * @returns {HttpClient} the client
	 */
	static create() {
		return new HttpClient(http);
	}

	/**
	 * Factory method. Creates a 'nulled' client that simulates HTTP requests rather than making real requests.
	 * @param [responses] An object that contains the simulated responses each endpoint should return. Each
	 * endpoint gets a property. The property name contains the path (e.g., '/') and the property value
	 * contains the simulated response. If a response isn't provided, a default 501 (not implemented) or
	 * 503 (service unavailable) response is returned.
	 * @param [responses.status] the status code to return
	 * @param [responses.headers] the headers to return
	 * @param [responses.body] the body to return
	 * @param [responses.hang] if true, the request never returns
	 * @returns {HttpClient} the nulled client
	 */
	static createNull(responses) {
		return new HttpClient(new StubbedHttp(responses));
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(http) {
		this._http = http;
		this._listener = OutputListener.create();
	}

	/**
	 * Track the HTTP requests that are made.
	 * @returns {OutputTracker} the request tracker
	 */
	trackRequests() {
		return this._listener.trackOutput();
	}

	/**
	 * Make the HTTP request. Does not have the ability to cancel the request.
	 * The response is an object containing { status, headers, body }.
	 * @param host the host to call
	 * @param port the port to use
	 * @param method the request method
	 * @param path the request path (URL)
	 * @param [headers] the request headers
	 * @param [body] the request body
	 * @returns {Promise} the response promise
	 */
	async requestAsync({ host, port, method, path, headers = {}, body = ""}) {
		ensure.signature(arguments, [{  // run-time type checker (ignore me)
			host: String,
			port: Number,
			method: String,
			path: String,
			headers: [ undefined, Object ],
			body: [ undefined, String ],
		}]);

		if (method.toLowerCase() === "get" && body !== "") {
			throw new Error("Don't include body with GET requests; Node won't send it");
		}

		const clientRequest = this.#sendRequest(host, port, method, path, headers, body);
		return await this.#handleResponseAsync(clientRequest);
	}

	#sendRequest(host, port, method, path, headers, body) {
		const clientRequest = this._http.request({
			host: host,
			port: port,
			method: method,
			path: path,
			headers: headers,
		});

		clientRequest.end(body);

		this._listener.emit({ host, port, method, path, headers, body });

		return clientRequest;
	}

	async #handleResponseAsync(clientRequest) {
		return await new Promise((resolve, reject) => {
			clientRequest.on("error", (err) => reject(err));

			clientRequest.on("response", (clientResponse) => {
				let body = "";
				clientResponse.on("data", (chunk) => {
					body += chunk;
				});

				clientResponse.on("end", () => {
					resolve({
						status: clientResponse.statusCode,
						headers: clientResponse.headers,
						body,
					});
				});
			});
		});
	}
}


class StubbedHttp {
	constructor(responses = {}) {
		this._responses = responses;
	}

	request({ path }) {
		return new StubbedRequest(this._responses[path]);
	}
}

class StubbedRequest extends EventEmitter {
	constructor(responses) {
		super();
		this._responses = responses;
	}

	end() {
		const response = nextResponse(this._responses);
		setImmediate(() => {
			this.emit("response", new StubbedResponse(response));
		});
	}
}

function nextResponse (responses) {
	if (Array.isArray(responses)) {
		if (responses.length === 0) {
			throw new Error("No more responses configured in Nulled HTTP client");
		}
		return responses.shift();
	} else {
		return responses;
	}
}

class StubbedResponse extends EventEmitter {
	constructor ({
		status = 501,
		headers = {},
		body = ""
	} = DEFAULT_NULLED_RESPONSE) {
		super();

		this.statusCode = status;
		this.headers = normalizeHeaders(headers);

		setImmediate(() => {
			this.emit("data", body);
			this.emit("end");
		});
	}
}

function normalizeHeaders (headers) {
	const originalEntries = Object.entries(headers);
	const transformedEntries = originalEntries.map(([key, value]) => [ key.toLowerCase(), value]);
	return Object.fromEntries(transformedEntries);
}