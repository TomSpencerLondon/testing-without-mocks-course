// Copyright Titanium I.T. LLC.
import * as ensure from "util/ensure.js";
import assert from "util/assert.js";
import http from "node:http";
import { HttpClient } from "http/http_client.js";
import { ignorePromiseErrorAsync } from "util/test_helper.js";

const HOST = "localhost";
const PORT = 5001;

describe.only("HTTP Client", () => {

	let spyServer;

	before(async () => {
		spyServer = new SpyServer();
		await spyServer.startAsync();
	});

	after(async () => {
		await spyServer.stopAsync();
	});

	describe("happy path", () => {

		it("performs request", async () => {
			console.log("CLIENT SENDING REQUEST");
			const clientRequest = http.request({
				host: HOST,
				port: PORT,
				method: "POST",
				path: "/my/path",
				headers: {
					myRequestHeader: "myRequestValue",
				},
			});
			clientRequest.end("my request body");

			const response = await new Promise((resolve, reject) => {
				clientRequest.on("response", (clientResponse) => {
					let body = "";
					clientResponse.on("data", (chunk) => {
						body += chunk;
					});

					clientResponse.on("end", () => {
						resolve({
							status: clientResponse.statusCode,
							headers: clientResponse.headers,
							body,
						});
					});
				});
			});
			console.log("EXCHANGE COMPLETE");

			delete response.headers.date;
			assert.deepEqual(response, {
				status: 999,
				headers: {
					myresponseheader: "myResponseValue",
					connection: "close",
					"content-length": "16",
				},
				body: "my response body",
			});
		});

		// Challenge #12
		it("returns response", async () => {
			// to do
		});

		// Challenge #12
		it("headers and body are optional", async () => {
			// to do
		});

	});


	describe("failure paths", () => {

		// Bonus Challenge #2
		it("fails gracefully if connection is refused", async () => {
			// to do
		});

		// Bonus Challenge #1
		it("fails fast if body is provided with GET request", async () => {
			// to do
		});

	});


	describe("cancellation", () => {

		// Bonus Challenge #4
		it("can cancel requests", async () => {
			// to do
		});

		// Bonus Challenge #5
		it("ignores additional requests to cancel", async () => {
			// to do
		});

		// Bonus Challenge #5
		it("ignores cancellation that occurs after response has been received", async () => {
			// to do
		});

	});

});


class SpyServer {

	async startAsync() {
		this._server = http.createServer();

		await new Promise((resolve, reject) => {
			this._server.listen(PORT);
			this._server.on("listening", () => resolve());
		});

		this._server.on("request", (serverRequest, serverResponse) => {
			console.log("SERVER RECEIVING REQUEST");

			let body = "";
			serverRequest.on("data", (chunk) => {
				body += chunk;
			});

			serverRequest.on("end", () => {
				console.log("SERVER RECEIVED ENTIRE REQUEST");
				console.log("SERVER RECEIVED METHOD:", serverRequest.method);
				console.log("SERVER RECEIVED PATH:", serverRequest.url);
				console.log("SERVER RECEIVED HEADERS:", serverRequest.headers);
				console.log("SERVER RECEIVED BODY:", body);

				serverResponse.statusCode = 999;
				serverResponse.setHeader("myResponseHeader", "myResponseValue");
				serverResponse.end("my response body");

				console.log("SERVER SENT RESPONSE");
			});
		});
	}

	async stopAsync() {
		await new Promise((resolve, reject) => {
			this._server.close();
			this._server.on("close", () => resolve());
		});
	}

}