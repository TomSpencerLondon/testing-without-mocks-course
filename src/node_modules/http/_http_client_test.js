// Copyright Titanium I.T. LLC.
import assert from 'util/assert.js';
import http from 'node:http';
import { HttpClient } from 'http/http_client.js';

const HOST = "localhost";
const PORT = 5001;

describe.only("HTTP Client", () => {

	let spyServer;

	before(async () => {
		spyServer = new SpyServer();
		await spyServer.startAsync();
	});

	beforeEach(() => {
		spyServer.reset();
	});

	after(async () => {
		await spyServer.stopAsync();
	});

	describe("happy path", () => {

		it("performs request", async () => {
			await requestAsync({
				host: HOST,
				port: PORT,
				method: "POST",
				path: "/my/path",
				headers: {
					myRequestHeader: "myRequestValue",
				},
				body: "my request body",
			});

			assert.deepEqual(spyServer.lastRequest, {
				method: "POST",
				path: "/my/path",
				headers: {
					myrequestheader: "myRequestValue",
					host: `${HOST}:${PORT}`,
					connection: "close",
					"content-length": "15",
				},
				body: "my request body",
			});
		});

		it("returns response", async () => {
			spyServer.setResponse({
				status: 999,
				headers: {
					myResponseHeader: "myResponseValue",
				},
				body: "my response body"
			});

			const { response } = await requestAsync();

			delete response.headers.date;
			assert.deepEqual(response, {
				status: 999,
				headers: {
					myresponseheader: "myResponseValue",
					connection: "close",
					"content-length": "16",
				},
				body: "my response body",
			});
		});

		it("headers and body are optional", async () => {
			await requestAsync({
				method: "GET",
				path: "/my/new/path",
				headers: undefined,
				body: undefined,
			});

			assert.deepEqual(spyServer.lastRequest, {
				method: "GET",
				path: "/my/new/path",
				headers: {
					"connection": "close",
					"host": `${HOST}:${PORT}`,
				},
				body: "",
			});
		});

	});


	describe("request tracking", () => {

		// Challenge #11
		it("tracks requests", async () => {
			const { requests } = await requestAsync({
				host: HOST,
				port: PORT,
				method: "POST",
				headers: { myHeader: "myValue" },
				path: "/my/path",
				body: "my body",
			});

			assert.deepEqual(requests.data, [{
				host: HOST,
				port: PORT,
				method: "POST",
				headers: { myHeader: "myValue" },
				path: "/my/path",
				body: "my body",
			}]);
		});

		// Bonus Challenge #1
		it("normalizes method and header names to lowercase", async () => {
			// to do
		});

	});


	describe("failure paths", () => {

		it("fails gracefully if connection is refused", async () => {
			await assert.throwsAsync(
				() => requestAsync({
					port: PORT + 1,      // connection should fail because no server is established at that port
				}),
				/ECONNREFUSED/,
			);
		});

		it("fails fast if body is provided with GET request", async () => {
			await assert.throwsAsync(
				() => requestAsync({
					method: "Get",
					body: "oops",
				}),
				"Don't include body with GET requests; Node won't send it",
			);
		});

	});


	describe("nulled instance", () => {

		// Challenges #1-2
		it("doesn't talk to network", async () => {
			const client = HttpClient.createNull();
			await requestAsync({ client });
			assert.equal(spyServer.lastRequest, null);
		});

		// Challenge #3
		it("provides default response", async () => {
			// to do
			const client = HttpClient.createNull();
			const { response } = await requestAsync({ client });

			assert.deepEqual(response, {
				status: 503,
				headers: { nulledhttpclient: "default header" },
				body: "Nulled HttpClient default body",
			});
		});

		// Challenges #4-5
		it("can be configured with a different response per endpoint", async () => {
			const client = HttpClient.createNull({
				"/endpoint/1": { status: 200, headers: { myHeader1: "myValue1" }, body: "my body 1" },
				"/endpoint/2": { status: 300, headers: { myHeader2: "myValue2" }, body: "my body 2" },
			});

			const { response: response1 } = await requestAsync({ client, path: "/endpoint/1" });
			const { response: response2 } = await requestAsync({ client, path: "/endpoint/2" });

			assert.deepEqual(response1, {
				status: 200,
				headers: { myheader1: "myValue1" },
				body: "my body 1",
			});
			assert.deepEqual(response2, {
				status: 300,
				headers: { myheader2: "myValue2" },
				body: "my body 2",
			});
		});

		// Challenge #6
		it("normalizes header names to lowercase (to match real behavior)", async () => {
			// to do
			const client = HttpClient.createNull({
				"/endpoint": {
					status: 200,
					headers: {
						MiXeDcAsE: "mixed",
						UPPERCASE: "upper",
						lowercase: "lower",
					},
					body: "my body"
				}
			});

			const { response } = await requestAsync({ client, path: "/endpoint" });

			assert.deepEqual(response, {
				status: 200,
				headers: {
					mixedcase: "mixed",
					uppercase: "upper",
					lowercase: "lower",
				},
				body: "my body",
			});
		});

		// Challenge #7
		it("provides defaults for partially-configured responses", async () => {
			// to do
			const client = HttpClient.createNull({
				"/endpoint": {},
			});

			const { response } = await requestAsync({ client, path: "/endpoint" });

			assert.deepEqual(response, {
				status: 501,
				headers: {},
				body: "",
			});

		});

		// Challenge #8
		it("provides an infinite number of responses when an endpoint has one response configured", async () => {
			// to do
			const client = HttpClient.createNull({
				"/endpoint": { status: 200, headers: { myheader: "myValue"}, body: "my body" },
			});

			const { response: response1 } = await requestAsync({ client, path: "/endpoint" });
			const { response: response2 } = await requestAsync({ client, path: "/endpoint" });

			assert.deepEqual(response1, {
				status: 200,
				headers: { myheader: "myValue" },
				body: "my body",
			});

			assert.deepEqual(response2, {
				status: 200,
				headers: { myheader: "myValue" },
				body: "my body",
			});
		});

		// Challenge #9
		it("provides distinct responses when an endpoint has a list of responses configured", async () => {
			const client = HttpClient.createNull({
				"/endpoint": [
					{ status: 200, headers: { myheader1: "myValue1" }, body: "my body 1" },
					{ status: 300, headers: { myheader2: "myValue2" }, body: "my body 2" },
				],
			});

			const { response: response1 } = await requestAsync({ client, path: "/endpoint" });
			const { response: response2 } = await requestAsync({ client, path: "/endpoint" });

			assert.deepEqual(response1, {
				status: 200,
				headers: { myheader1: "myValue1"},
				body: "my body 1",
			});
			assert.deepEqual(response2, {
				status: 300,
				headers: { myheader2: "myValue2" },
				body: "my body 2",
			});
		});

		// Challenge #10
		it("throws exception when list of configured responses runs out", async () => {
			const client = HttpClient.createNull({
				"/endpoint": [{ status: 200, body: "my body" }],
			});

			await assert.doesNotThrowAsync(
				() => requestAsync({ client, path: "/endpoint" }),
			);

			await assert.throwsAsync(
				() => requestAsync({ client, path: "/endpoint" }),
				"No more responses configured in Nulled HTTP client",
			);


		});

		// Bonus Challenge #2
		it("simulates hangs", async () => {
			// to do
		});

	});

});


async function requestAsync({
	client = HttpClient.create(),
	host = HOST,
	port = PORT,
	method = "GET",
	path = "/irrelevant/path",
	headers = undefined,
	body = undefined,
} = {}) {
	const requests = client.trackRequests();
	const response = await client.requestAsync({ host, port, method, path, headers, body });
	return { response, requests };
}


class SpyServer {

	constructor() {
		this.reset();
	}

	reset() {
		this.lastRequest = null;
		this.setResponse({
			status: 501,
			headers: {},
			body: "SpyServer response not specified",
		});
	}

	setResponse(response) {
		this._response = response;
	}

	async startAsync() {
		this._server = http.createServer();

		await new Promise((resolve, reject) => {
			this._server.listen(PORT);
			this._server.on("listening", () => resolve());
		});

		this._server.on("request", (serverRequest, serverResponse) => {
			let body = "";
			serverRequest.on("data", (chunk) => {
				body += chunk;
			});

			serverRequest.on("end", () => {
				this.lastRequest = {
					method: serverRequest.method,
					path: serverRequest.url,
					headers: serverRequest.headers,
					body,
				};

				serverResponse.statusCode = this._response.status;
				Object.entries(this._response.headers).forEach(([ key, value ]) => {
					serverResponse.setHeader(key, value);
				});
				serverResponse.end(this._response.body);
			});
		});
	}

	async stopAsync() {
		await new Promise((resolve, reject) => {
			this._server.close();
			this._server.on("close", () => resolve());
		});
	}
}