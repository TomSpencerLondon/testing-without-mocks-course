// Copyright Titanium I.T. LLC.
import * as ensure from "util/ensure.js";
import assert from "util/assert.js";
import http from "node:http";
import { HttpClient } from "http/http_client.js";
import { ignorePromiseErrorAsync } from "util/test_helper.js";

const HOST = "localhost";
const PORT = 5001;

describe.only("HTTP Client", () => {

	let spyServer;

	before(async () => {
		spyServer = new SpyServer();
		await spyServer.startAsync();
	});

	beforeEach(() => {
		spyServer.reset();
	});

	after(async () => {
		await spyServer.stopAsync();
	});

	describe("happy path", () => {

		it("performs request", async () => {
			await requestAsync({
				host: HOST,
				port: PORT,
				method: "POST",
				path: "/my/path",
				headers: {
					myRequestHeader: "myRequestValue",
				},
				body: "my request body",
			});

			assert.deepEqual(spyServer.lastRequest, {
				method: "POST",
				path: "/my/path",
				headers: {
					myrequestheader: "myRequestValue",
					host: `${HOST}:${PORT}`,
					connection: "close",
					"content-length": "15",
				},
				body: "my request body",
			});
		});

		it("returns response", async () => {
			spyServer.setResponse({
				status: 999,
				headers: {
					myResponseHeader: "myResponseValue",
				},
				body: "my response body"
			});

			const { response } = await requestAsync();

			delete response.headers.date;
			assert.deepEqual(response, {
				status: 999,
				headers: {
					myresponseheader: "myResponseValue",
					connection: "close",
					"content-length": "16",
				},
				body: "my response body",
			});
		});

		it("headers and body are optional", async () => {
			await requestAsync({
				method: "GET",
				path: "/my/new/path",
				headers: undefined,
				body: undefined,
			});

			assert.deepEqual(spyServer.lastRequest, {
				method: "GET",
				path: "/my/new/path",
				headers: {
					"connection": "close",
					"host": `${HOST}:${PORT}`,
				},
				body: "",
			});
		});

	});


	describe("request tracking", () => {

		// Challenge #11
		it("tracks requests", async () => {
			// to do
		});

		// Bonus Challenge #1
		it("normalizes method and header names to lowercase", async () => {
			// to do
		});

	});


	describe("failure paths", () => {

		it("fails gracefully if connection is refused", async () => {
			await assert.throwsAsync(
				() => requestAsync({
					port: PORT + 1,      // connection should fail because no server is established at that port
				}),
				/ECONNREFUSED/,
			);
		});

		it("fails fast if body is provided with GET request", async () => {
			await assert.throwsAsync(
				() => requestAsync({
					method: "Get",
					body: "oops",
				}),
				"Don't include body with GET requests; Node won't send it",
			);
		});

	});


	describe("nulled instance", () => {

		// Challenges #1-2
		it("doesn't talk to network", async () => {
			const client = HttpClient.createNull();
			await requestAsync({ client });
			assert.equal(spyServer.lastRequest, null);
		});

		// Challenge #3
		it("provides default response", async () => {
			// to do
			const client = HttpClient.createNull();
			const { response } = await requestAsync({ client });

			assert.deepEqual(response, {
				status: 503,
				headers: { nulledhttpclient: "default header" },
				body: "Nulled HttpClient default body",
			});
		});

		// Challenges #4-5
		it("can be configured with a different response per endpoint", async () => {
			// to do
		});

		// Challenge #6
		it("normalizes header names to lowercase (to match real behavior)", async () => {
			// to do
		});

		// Challenge #7
		it("provides defaults for partially-configured responses", async () => {
			// to do
		});

		// Challenge #8
		it("provides an infinite number of responses when an endpoint has one response configured", async () => {
			// to do
		});

		// Challenge #9
		it("provides distinct responses when an endpoint has a list of responses configured", async () => {
			// to do
		});

		// Challenge #10
		it("throws exception when list of configured responses runs out", async () => {
			// to do
		});

		// Bonus Challenge #2
		it("simulates hangs", async () => {
			// to do
		});

	});

});

async function requestAsync({
	client = HttpClient.create(),
	host = HOST,
	port = PORT,
	method = "GET",
	path = "/irrelevant/path",
	headers = undefined,
	body = undefined,
} = {}) {
	const response = await client.requestAsync({ host, port, method, path, headers, body });
	return { response };
}


class SpyServer {

	constructor() {
		this.reset();
	}

	reset() {
		this.lastRequest = null;
		this.setResponse({
			status: 501,
			headers: {},
			body: "SpyServer response not specified",
		});
	}

	setResponse(response) {
		this._response = response;
	}

	async startAsync() {
		this._server = http.createServer();

		await new Promise((resolve, reject) => {
			this._server.listen(PORT);
			this._server.on("listening", () => resolve());
		});

		this._server.on("request", (serverRequest, serverResponse) => {
			let body = "";
			serverRequest.on("data", (chunk) => {
				body += chunk;
			});

			serverRequest.on("end", () => {
				this.lastRequest = {
					method: serverRequest.method,
					path: serverRequest.url,
					headers: serverRequest.headers,
					body,
				};

				serverResponse.statusCode = this._response.status;
				Object.entries(this._response.headers).forEach(([ key, value ]) => {
					serverResponse.setHeader(key, value);
				});
				serverResponse.end(this._response.body);
			});
		});
	}

	async stopAsync() {
		await new Promise((resolve, reject) => {
			this._server.close();
			this._server.on("close", () => resolve());
		});
	}

}