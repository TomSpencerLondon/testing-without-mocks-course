// Copyright Titanium I.T. LLC.
import * as ensure from "util/ensure.js";
import assert from "util/assert.js";
import http from "node:http";
import { HttpClient } from "http/http_client.js";
import { ignorePromiseErrorAsync } from "util/test_helper.js";

const HOST = "localhost";
const PORT = 5001;

describe.only("HTTP Client", () => {

	let spyServer;

	before(async () => {
		spyServer = new SpyServer();
		await spyServer.startAsync();
	});

	beforeEach(() => {
		spyServer.reset();
	});

	after(async () => {
		await spyServer.stopAsync();
	});

	describe("happy path", () => {

		it("performs request", async () => {
			spyServer.setResponse({
				status: 999,
				headers: {
					myResponseHeader: "myResponseValue",
				},
				body: "my response body"
			});

			const { response } = await requestAsync({
				host: HOST,
				port: PORT,
				method: "POST",
				path: "/my/path",
				headers: {
					myRequestHeader: "myRequestValue",
				},
				body: "my request body",
			});

			assert.deepEqual(spyServer.lastRequest, {
				method: "POST",
				path: "/my/path",
				headers: {
					myrequestheader: "myRequestValue",
					host: `${HOST}:${PORT}`,
					connection: "close",
					"content-length": "15",
				},
				body: "my request body",
			});

			delete response.headers.date;
			assert.deepEqual(response, {
				status: 999,
				headers: {
					myresponseheader: "myResponseValue",
					connection: "close",
					"content-length": "16",
				},
				body: "my response body",
			});
		});

		// Challenge #12
		it("returns response", async () => {
			// to do
		});

		// Challenge #12
		it("headers and body are optional", async () => {
			// to do
		});

	});


	describe("failure paths", () => {

		// Bonus Challenge #2
		it("fails gracefully if connection is refused", async () => {
			// to do
		});

		// Bonus Challenge #1
		it("fails fast if body is provided with GET request", async () => {
			// to do
		});

	});


	describe("cancellation", () => {

		// Bonus Challenge #4
		it("can cancel requests", async () => {
			// to do
		});

		// Bonus Challenge #5
		it("ignores additional requests to cancel", async () => {
			// to do
		});

		// Bonus Challenge #5
		it("ignores cancellation that occurs after response has been received", async () => {
			// to do
		});

	});

});

async function requestAsync({
	host = HOST,
	port = PORT,
	method = "GET",
	path = "/irrelevant/path",
	headers = undefined,
	body = undefined,
} = {}) {
	const client = HttpClient.create();
	const response = await client.requestAsync({ host, port, method, path, headers, body });
	return { response };
}


class SpyServer {

	constructor() {
		this.reset();
	}

	reset() {
		this.lastRequest = null;
		this.setResponse({
			status: 501,
			headers: {},
			body: "SpyServer response not specified",
		});
	}

	setResponse(response) {
		this._response = response;
	}

	async startAsync() {
		this._server = http.createServer();

		await new Promise((resolve, reject) => {
			this._server.listen(PORT);
			this._server.on("listening", () => resolve());
		});

		this._server.on("request", (serverRequest, serverResponse) => {
			let body = "";
			serverRequest.on("data", (chunk) => {
				body += chunk;
			});

			serverRequest.on("end", () => {
				this.lastRequest = {
					method: serverRequest.method,
					path: serverRequest.url,
					headers: serverRequest.headers,
					body,
				};

				serverResponse.statusCode = this._response.status;
				Object.entries(this._response.headers).forEach(([ key, value ]) => {
					serverResponse.setHeader(key, value);
				});
				serverResponse.end(this._response.body);
			});
		});
	}

	async stopAsync() {
		await new Promise((resolve, reject) => {
			this._server.close();
			this._server.on("close", () => resolve());
		});
	}

}